import Parser from 'tree-sitter';
import { CodeAnalyzer, AnalysisResult, AnalysisContext } from './types';
import { exec } from 'child_process';
import util from 'util';
import path from 'path';

const execPromise = util.promisify(exec);

// Interface for the structure of `npm audit --json` output (simplified)
interface NpmAuditAdvisory {
    module_name: string;
    severity: 'info' | 'low' | 'moderate' | 'high' | 'critical';
    title: string;
    vulnerable_versions: string;
    recommendation: string;
    url: string;
    via: (string | { source: number; name: string })[]; // Can be complex
}
interface NpmAuditJson {
    advisories: { [advisoryId: string]: NpmAuditAdvisory };
    // Other fields exist but advisories is key
}

export class DependencyVulnerabilityAnalyzer implements CodeAnalyzer {
    name = 'dependency-vulnerability';
    description = 'Checks for known vulnerabilities in project dependencies using `npm audit`.';

    private hasRun = false; // Ensure npm audit runs only once per analysis session

    async analyze(tree: Parser.Tree, context?: AnalysisContext): Promise<AnalysisResult[]> {
        // This analyzer doesn't use the tree, it runs an external command based on project root.
        // Run only once per session to avoid redundant checks.
        if (this.hasRun || !context?.projectRoot) {
             if (!context?.projectRoot) {
                  console.warn('[DependencyVulnerabilityAnalyzer] Skipping: projectRoot not provided in context.');
             }
            return [];
        }

        const projectRoot = context.projectRoot;
        const results: AnalysisResult[] = [];
        this.hasRun = true; // Mark as run for this session
        console.log(`[DependencyVulnerabilityAnalyzer] Running npm audit in ${projectRoot}...`);

        try {
            // Execute npm audit --json in the target project directory
            const { stdout, stderr } = await execPromise('npm audit --json', { cwd: projectRoot });

            if (stderr) {
                // npm audit often outputs non-error info to stderr, especially exit code > 0 if vulns found
                 console.warn(`[DependencyVulnerabilityAnalyzer] npm audit stderr: ${stderr}`);
                 // Continue processing stdout even if stderr has content, unless stdout is empty
            }
            
            if (!stdout) {
                console.log('[DependencyVulnerabilityAnalyzer] No output from npm audit.');
                 return []; // No vulnerabilities reported or command failed silently
            }

            const auditData: NpmAuditJson = JSON.parse(stdout);

            if (auditData.advisories) {
                for (const advisoryId in auditData.advisories) {
                    const advisory = auditData.advisories[advisoryId];
                    const severity = advisory.severity === 'info' ? 'info' : 
                                     (advisory.severity === 'low' || advisory.severity === 'moderate') ? 'warning' : 'error'; // Map severity
                    
                    // Try to find the top-level dependency path if available
                    let viaPath = '';
                    if (Array.isArray(advisory.via)) {
                        const topLevel = advisory.via.find(v => typeof v === 'string');
                        if (topLevel) {
                            viaPath = ` via ${topLevel}`;
                        } else {
                             // Find first named dependency if only objects exist
                             const firstVia = advisory.via.find(v => typeof v !== 'string' && v.name) as { name: string } | undefined;
                             if(firstVia) viaPath = ` via ${firstVia.name} > ...`;
                        }
                    }

                    // Construct the AnalysisResult correctly in the TRY block
                    results.push({
                        analyzer: this.name,
                        line: 0, // Project-level issue
                        type: severity, // Use calculated severity for type
                        message: `[${advisory.severity.toUpperCase()}] ${advisory.title} - Package: ${advisory.module_name} (${advisory.vulnerable_versions})${viaPath}. Recommendation: ${advisory.recommendation}. See: ${advisory.url}`,
                        diagnostic: { 
                            package: advisory.module_name,
                            severityLevel: advisory.severity,
                            vulnerableVersions: advisory.vulnerable_versions,
                            recommendation: advisory.recommendation,
                            url: advisory.url
                         }
                    });
                }
            }
             console.log(`[DependencyVulnerabilityAnalyzer] Found ${results.length} advisories.`);

        } catch (error: any) {
            // npm audit exits with code > 0 if vulnerabilities are found. 
            // We need to check if it's a real error or just found issues.
             if (error.stdout) {
                 try {
                    // Attempt to parse JSON even if exit code was non-zero
                     const auditData: NpmAuditJson = JSON.parse(error.stdout);
                     // Reprocess advisories (duplicate code - potential refactor needed)
                     if (auditData.advisories) {
                         for (const advisoryId in auditData.advisories) {
                             const advisory = auditData.advisories[advisoryId];
                             const severity = advisory.severity === 'info' ? 'info' :
                                              (advisory.severity === 'low' || advisory.severity === 'moderate') ? 'warning' : 'error';
                            
                             // Duplicate logic for finding viaPath (matches try block)
                             let viaPath = '';
                             if (Array.isArray(advisory.via)) {
                                 const topLevel = advisory.via.find(v => typeof v === 'string');
                                 if (topLevel) {
                                     viaPath = ` via ${topLevel}`;
                                 } else {
                                      const firstVia = advisory.via.find(v => typeof v !== 'string' && v.name) as { name: string } | undefined;
                                      if(firstVia) viaPath = ` via ${firstVia.name} > ...`;
                                 }
                             }
                             // Construct the AnalysisResult correctly in the CATCH block
                             results.push({
                                 analyzer: this.name, 
                                 line: 0,            
                                 type: severity,     
                                 message: `[${advisory.severity.toUpperCase()}] ${advisory.title} - Package: ${advisory.module_name} (${advisory.vulnerable_versions})${viaPath}. Recommendation: ${advisory.recommendation}. See: ${advisory.url}`,
                                 diagnostic: {       
                                     package: advisory.module_name,
                                     severityLevel: advisory.severity,
                                     vulnerableVersions: advisory.vulnerable_versions,
                                     recommendation: advisory.recommendation,
                                     url: advisory.url
                                  }
                             });
                         }
                     }
                      console.log(`[DependencyVulnerabilityAnalyzer] Found ${results.length} advisories (reported via error stdout).`);
                 } catch (parseError) {
                     console.error('[DependencyVulnerabilityAnalyzer] Failed to parse npm audit JSON from error stdout:', parseError);
                     results.push({ 
                         analyzer: this.name,
                         line: 0,
                         type: 'error', // Use 'error' type
                         message: `Failed to run or parse 'npm audit --json'. Error: ${error.message || 'Unknown error'}`,
                         diagnostic: { // Add diagnostic context
                             rawError: String(error),
                             parseError: String(parseError)
                         }
                     });
                 }
             } else {
                 console.error('[DependencyVulnerabilityAnalyzer] Error executing npm audit:', error);
                 results.push({ 
                    analyzer: this.name,
                    line: 0,
                    type: 'error', // Use 'error' type
                    message: `Failed to execute 'npm audit --json'. Error: ${error.message || 'Unknown error'}`,
                     diagnostic: { // Add diagnostic context
                        rawError: String(error)
                    }
                 });
             }
        } finally {
             this.hasRun = false; // Reset for potential next run if needed (e.g., in watch mode)
        }

        return results;
    }
} 